<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Real-Time Interrupt-driven Concurrency</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="preface.html">Preface</a></li><li class="chapter-item expanded "><a href="by-example.html"><strong aria-hidden="true">1.</strong> RTIC by example</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="by-example/app.html"><strong aria-hidden="true">1.1.</strong> The app attribute</a></li><li class="chapter-item expanded "><a href="by-example/resources.html"><strong aria-hidden="true">1.2.</strong> Resources</a></li><li class="chapter-item expanded "><a href="by-example/tasks.html"><strong aria-hidden="true">1.3.</strong> Software tasks</a></li><li class="chapter-item expanded "><a href="by-example/timer-queue.html"><strong aria-hidden="true">1.4.</strong> Timer queue</a></li><li class="chapter-item expanded "><a href="by-example/types-send-sync.html"><strong aria-hidden="true">1.5.</strong> Types, Send and Sync</a></li><li class="chapter-item expanded "><a href="by-example/new.html"><strong aria-hidden="true">1.6.</strong> Starting a new project</a></li><li class="chapter-item expanded "><a href="by-example/tips.html"><strong aria-hidden="true">1.7.</strong> Tips &amp; tricks</a></li></ol></li><li class="chapter-item expanded "><a href="migration.html"><strong aria-hidden="true">2.</strong> Migration Guides</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="migration/migration_v5.html"><strong aria-hidden="true">2.1.</strong> v0.5.x to v0.6.x</a></li><li class="chapter-item expanded "><a href="migration/migration_v4.html"><strong aria-hidden="true">2.2.</strong> v0.4.x to v0.5.x</a></li><li class="chapter-item expanded "><a href="migration/migration_rtic.html"><strong aria-hidden="true">2.3.</strong> RTFM to RTIC</a></li></ol></li><li class="chapter-item expanded "><a href="internals.html"><strong aria-hidden="true">3.</strong> Under the hood</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Real-Time Interrupt-driven Concurrency</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/rtic-rs/cortex-m-rtic" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div align="center"><img width="300" height="300" src="RTIC.svg"></div>
<div style="font-size: 6em; font-weight: bolder;" align="center">RTIC</div>
<h1 align="center">Real-Time Interrupt-driven Concurrency</h1>
<p align="center">A concurrency framework for building real-time systems</p>
<h1 id="preface"><a class="header" href="#preface">Preface</a></h1>
<p>This book contains user level documentation for the Real-Time Interrupt-driven Concurrency
(RTIC) framework. The API reference can be found <a href="../../api/">here</a>.</p>
<p>Formerly known as Real-Time For the Masses.</p>
<!--There is a translation of this book in [Russian].-->
<!--[Russian]: ../ru/index.html-->
<p>This is the documentation of v0.6.x of RTIC; for the documentation of version</p>
<ul>
<li>v0.5.x go <a href="/0.5">here</a>.</li>
<li>v0.4.x go <a href="/0.4">here</a>.</li>
</ul>
<p><a href="https://crates.io/crates/cortex-m-rtic"><img src="https://img.shields.io/crates/v/cortex-m-rtic" alt="crates.io" /></a>
<a href="https://docs.rs/cortex-m-rtic"><img src="https://docs.rs/cortex-m-rtic/badge.svg" alt="docs.rs" /></a>
<a href="https://rtic.rs/"><img src="https://img.shields.io/badge/web-rtic.rs-red.svg?style=flat&amp;label=book&amp;colorB=d33847" alt="book" /></a>
<a href="https://github.com/rust-lang/rust/releases/tag/1.36.0"><img src="https://img.shields.io/badge/rustc-1.36+-lightgray.svg" alt="rustc" /></a>
<a href="https://matrix.to/#/#rtic:matrix.org"><img src="https://img.shields.io/matrix/rtic:matrix.org" alt="matrix" /></a>
<a href="https://hackmd.io/@xmis9JvZT8Gvo9lOEKyZ4Q/SkBJKsjuH"><img src="https://hackmd.io/badge.svg" alt="Meeting notes" /></a></p>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<ul>
<li>
<p><strong>Tasks</strong> as the unit of concurrency <sup class="footnote-reference"><a href="#1">1</a></sup>. Tasks can be <em>event triggered</em>
(fired in response to asynchronous stimuli) or spawned by the application on
demand.</p>
</li>
<li>
<p><strong>Message passing</strong> between tasks. Specifically, messages can be passed to
software tasks at spawn time.</p>
</li>
<li>
<p><strong>A timer queue</strong> <sup class="footnote-reference"><a href="#2">2</a></sup>. Software tasks can be scheduled to run at some time
in the future. This feature can be used to implement periodic tasks.</p>
</li>
<li>
<p>Support for prioritization of tasks and, thus, <strong>preemptive multitasking</strong>.</p>
</li>
<li>
<p><strong>Efficient and data race free memory sharing</strong> through fine grained <em>priority
based</em> critical sections <sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
</li>
<li>
<p><strong>Deadlock free execution</strong> guaranteed at compile time. This is an stronger
guarantee than what's provided by <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html">the standard <code>Mutex</code>
abstraction</a>.</p>
</li>
</ul>
<ul>
<li>
<p><strong>Minimal scheduling overhead</strong>. The task scheduler has minimal software
footprint; the hardware does the bulk of the scheduling.</p>
</li>
<li>
<p><strong>Highly efficient memory usage</strong>: All the tasks share a single call stack and
there's no hard dependency on a dynamic memory allocator.</p>
</li>
<li>
<p><strong>All Cortex-M devices are fully supported</strong>.</p>
</li>
<li>
<p>This task model is amenable to known WCET (Worst Case Execution Time) analysis
and scheduling analysis techniques. (Though we haven't yet developed Rust</p>
</li>
<li>
<p>Applications must be written using the 2018 edition.</p>
</li>
</ul>
<h2 id="a-hrefhttpsrticrsuser-documentationa"><a class="header" href="#a-hrefhttpsrticrsuser-documentationa"><a href="https://rtic.rs">User documentation</a></a></h2>
<h2 id="a-hrefhttpsrticrsstableapiapi-referencea"><a class="header" href="#a-hrefhttpsrticrsstableapiapi-referencea"><a href="https://rtic.rs/stable/api/">API reference</a></a></h2>
<h2 id="chat"><a class="header" href="#chat">Chat</a></h2>
<p>Join us and talk about RTIC in the <a href="https://matrix.to/#/#rtic:matrix.org">Matrix room</a>.</p>
<p>Weekly meeting notes can be found over at <a href="https://hackmd.io/@xmis9JvZT8Gvo9lOEKyZ4Q/SkBJKsjuH">HackMD</a></p>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>New features and big changes should go through the RFC process in the
<a href="https://github.com/rtic-rs/rfcs">dedicated RFC repository</a>.</p>
<h2 id="acknowledgments"><a class="header" href="#acknowledgments">Acknowledgments</a></h2>
<p>This crate is based on the <a href="http://www.rtfm-lang.org/">Real-Time For the Masses language</a>
created by the Embedded Systems group at <a href="https://www.ltu.se/?l=en">Luleå University of Technology</a>,
led by <a href="https://www.ltu.se/staff/p/pln-1.11258?l=en">Prof. Per Lindgren</a>.</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Eriksson, J., Häggström, F., Aittamaa, S., Kruglyak, A., &amp; Lindgren, P.
(2013, June). Real-time for the masses, step 1: Programming API and static
priority SRP kernel primitives. In Industrial Embedded Systems (SIES), 2013
8th IEEE International Symposium on (pp. 110-113). IEEE.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Lindgren, P., Fresk, E., Lindner, M., Lindner, A., Pereira, D., &amp; Pinho,
L. M. (2016). Abstract timers and their implementation onto the arm cortex-m
family of mcus. ACM SIGBED Review, 13(1), 48-53.</p>
</div>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>All source code (including code snippets) is licensed under either of</p>
<ul>
<li>Apache License, Version 2.0 (<a href="LICENSE-APACHE">LICENSE-APACHE</a> or
<a href="https://www.apache.org/licenses/LICENSE-2.0">https://www.apache.org/licenses/LICENSE-2.0</a>)</li>
<li>MIT license (<a href="LICENSE-MIT">LICENSE-MIT</a> or
<a href="https://opensource.org/licenses/MIT">https://opensource.org/licenses/MIT</a>)</li>
</ul>
<p>at your option.</p>
<p>The written prose contained within the book is licensed under the terms of the
Creative Commons CC-BY-SA v4.0 license (<a href="LICENSE-CC-BY-SA">LICENSE-CC-BY-SA</a> or
<a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">https://creativecommons.org/licenses/by-sa/4.0/legalcode</a>).</p>
<h3 id="contribution"><a class="header" href="#contribution">Contribution</a></h3>
<p>Unless you explicitly state otherwise, any contribution intentionally submitted
for inclusion in the work by you, as defined in the Apache-2.0 license, shall be
licensed as above, without any additional terms or conditions.</p>
<h1 id="rtic-by-example"><a class="header" href="#rtic-by-example">RTIC by example</a></h1>
<p>This part of the book introduces the Real-Time Interrupt-driven Concurrency (RTIC) framework
to new users by walking them through examples of increasing complexity.</p>
<p>All examples in this part of the book can be found in the GitHub <a href="https://github.com/rtic-rs/cortex-m-rtic">repository</a> of
the project, and most of the examples can be run on QEMU so no special hardware
is required to follow along.</p>
<p>To run the examples on your computer you'll need the <code>qemu-system-arm</code>
program. Check <a href="https://rust-embedded.github.io/book/intro/install.html">the embedded Rust book</a> for instructions on how to set up an
embedded development environment that includes QEMU.</p>
<h2 id="real-world-examples"><a class="header" href="#real-world-examples">Real World Examples</a></h2>
<p>The following are examples of RTFM being used in real world projects.</p>
<h3 id="rtfm-v042"><a class="header" href="#rtfm-v042">RTFM V0.4.2</a></h3>
<ul>
<li><a href="https://github.com/etrombly/sandbox/tree/41d423bcdd0d8e42fd46b79771400a8ca349af55">etrombly/sandbox</a>. A hardware zen garden that draws patterns in sand. Patterns are sent over serial using G-code.</li>
</ul>
<h1 id="the-app-attribute"><a class="header" href="#the-app-attribute">The <code>app</code> attribute</a></h1>
<p>This is the smallest possible RTIC application:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! examples/smallest.rs

#![no_main]
#![no_std]

use panic_semihosting as _; // panic handler
use rtic::app;

#[app(device = lm3s6965)]
mod app {}
<span class="boring">}
</span></code></pre></pre>
<p>All RTIC applications use the <a href="by-example/../../../api/cortex_m_rtic_macros/attr.app.html"><code>app</code></a> attribute (<code>#[app(..)]</code>). This attribute
must be applied to a <code>mod</code>-item. The <code>app</code> attribute has a mandatory <code>device</code>
argument that takes a <em>path</em> as a value. This must be a full path pointing to a
<em>peripheral access crate</em> (PAC) generated using <a href="https://crates.io/crates/svd2rust"><code>svd2rust</code></a> <strong>v0.14.x</strong> or
newer. More details can be found in the <a href="by-example/./new.html">Starting a new project</a>
section.</p>
<p>The <code>app</code> attribute will expand into a suitable entry point so it's not required
to use the <a href="by-example/../../../api/cortex_m_rt_macros/attr.entry.html"><code>cortex_m_rt::entry</code></a> attribute.</p>
<h2 id="init"><a class="header" href="#init"><code>init</code></a></h2>
<p>Within the <code>app</code> module the attribute expects to find an initialization
function marked with the <code>init</code> attribute. This function must have signature
<code>fn(init::Context) [-&gt; init::LateResources]</code> (the return type is not always
required).</p>
<p>This initialization function will be the first part of the application to run.
The <code>init</code> function will run <em>with interrupts disabled</em> and has exclusive access
to Cortex-M where the <code>bare_metal::CriticalSection</code> token is available as <code>cs</code>.
And optionally, device specific peripherals through the <code>core</code> and <code>device</code> fields
of <code>init::Context</code>.</p>
<p><code>static mut</code> variables declared at the beginning of <code>init</code> will be transformed
into <code>&amp;'static mut</code> references that are safe to access. Notice, this feature may be deprecated in next release, see <code>task_local</code> resources.</p>
<p>The example below shows the types of the <code>core</code>, <code>device</code> and <code>cs</code> fields, and
showcases safe access to a <code>static mut</code> variable. The <code>device</code> field is only
available when the <code>peripherals</code> argument is set to <code>true</code> (default). In the rare case you want to implement an ultra-slim application you can explicitly set <code>peripherals</code> to <code>false</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! examples/init.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

use panic_semihosting as _;

#[rtic::app(device = lm3s6965, peripherals = true)]
mod app {
    use cortex_m_semihosting::{debug, hprintln};

    #[init]
    fn init(cx: init::Context) -&gt; (init::LateResources, init::Monotonics) {
        static mut X: u32 = 0;

        // Cortex-M peripherals
        let _core: cortex_m::Peripherals = cx.core;

        // Device specific peripherals
        let _device: lm3s6965::Peripherals = cx.device;

        // Safe access to local `static mut` variable
        let _x: &amp;'static mut u32 = X;

        // Access to the critical section token,
        // to indicate that this is a critical seciton
        let _cs_token: bare_metal::CriticalSection = cx.cs;

        hprintln!(&quot;init&quot;).unwrap();

        debug::exit(debug::EXIT_SUCCESS);

        (init::LateResources {}, init::Monotonics())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Running the example will print <code>init</code> to the console and then exit the QEMU
process.</p>
<pre><code class="language-console">$ cargo run --example init
init
</code></pre>
<h2 id="idle"><a class="header" href="#idle"><code>idle</code></a></h2>
<p>A function marked with the <code>idle</code> attribute can optionally appear in the
module. This function is used as the special <em>idle task</em> and must have
signature <code>fn(idle::Context) - &gt; !</code>.</p>
<p>When present, the runtime will execute the <code>idle</code> task after <code>init</code>. Unlike
<code>init</code>, <code>idle</code> will run <em>with interrupts enabled</em> and it's not allowed to return
so it must run forever.</p>
<p>When no <code>idle</code> function is declared, the runtime sets the <a href="https://developer.arm.com/docs/100737/0100/power-management/sleep-mode/sleep-on-exit-bit">SLEEPONEXIT</a> bit and
then sends the microcontroller to sleep after running <code>init</code>.</p>
<p>Like in <code>init</code>, <code>static mut</code> variables will be transformed into <code>&amp;'static mut</code>
references that are safe to access. Notice, this feature may be deprecated in the next release, see <code>task_local</code> resources.</p>
<p>The example below shows that <code>idle</code> runs after <code>init</code>.</p>
<p><strong>Note:</strong> The <code>loop {}</code> in idle cannot be empty as this will crash the microcontroller due to
LLVM compiling empty loops to an <code>UDF</code> instruction in release mode. To avoid UB, the loop needs to imply a &quot;side-effect&quot; by inserting an assembly instruction (e.g., <code>WFI</code>) or a <code>continue</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! examples/idle.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

use panic_semihosting as _;

#[rtic::app(device = lm3s6965)]
mod app {
    use cortex_m_semihosting::{debug, hprintln};

    #[init]
    fn init(_: init::Context) -&gt; (init::LateResources, init::Monotonics) {
        hprintln!(&quot;init&quot;).unwrap();

        (init::LateResources {}, init::Monotonics())
    }

    #[idle]
    fn idle(_: idle::Context) -&gt; ! {
        static mut X: u32 = 0;

        // Safe access to local `static mut` variable
        let _x: &amp;'static mut u32 = X;

        hprintln!(&quot;idle&quot;).unwrap();

        debug::exit(debug::EXIT_SUCCESS);

        loop {
            cortex_m::asm::nop();
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-console">$ cargo run --example idle
init
idle
</code></pre>
<h2 id="hardware-tasks"><a class="header" href="#hardware-tasks">Hardware tasks</a></h2>
<p>To declare interrupt handlers the framework provides a <code>#[task]</code> attribute that
can be attached to functions. This attribute takes a <code>binds</code> argument whose
value is the name of the interrupt to which the handler will be bound to; the
function adorned with this attribute becomes the interrupt handler. Within the
framework these type of tasks are referred to as <em>hardware</em> tasks, because they
start executing in reaction to a hardware event.</p>
<p>The example below demonstrates the use of the <code>#[task]</code> attribute to declare an
interrupt handler. Like in the case of <code>#[init]</code> and <code>#[idle]</code> local <code>static mut</code> variables are safe to use within a hardware task.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! examples/hardware.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

use panic_semihosting as _;

#[rtic::app(device = lm3s6965)]
mod app {
    use cortex_m_semihosting::{debug, hprintln};
    use lm3s6965::Interrupt;

    #[init]
    fn init(_: init::Context) -&gt; (init::LateResources, init::Monotonics) {
        // Pends the UART0 interrupt but its handler won't run until *after*
        // `init` returns because interrupts are disabled
        rtic::pend(Interrupt::UART0); // equivalent to NVIC::pend

        hprintln!(&quot;init&quot;).unwrap();

        (init::LateResources {}, init::Monotonics())
    }

    #[idle]
    fn idle(_: idle::Context) -&gt; ! {
        // interrupts are enabled again; the `UART0` handler runs at this point

        hprintln!(&quot;idle&quot;).unwrap();

        rtic::pend(Interrupt::UART0);

        debug::exit(debug::EXIT_SUCCESS);

        loop {
            cortex_m::asm::nop();
        }
    }

    #[task(binds = UART0)]
    fn uart0(_: uart0::Context) {
        static mut TIMES: u32 = 0;

        // Safe access to local `static mut` variable
        *TIMES += 1;

        hprintln!(
            &quot;UART0 called {} time{}&quot;,
            *TIMES,
            if *TIMES &gt; 1 { &quot;s&quot; } else { &quot;&quot; }
        )
        .unwrap();
    }
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-console">$ cargo run --example hardware
init
UART0 called 1 time
idle
UART0 called 2 times
</code></pre>
<p>So far all the RTIC applications we have seen look no different than the
applications one can write using only the <code>cortex-m-rt</code> crate. From this point
we start introducing features unique to RTIC.</p>
<h2 id="priorities"><a class="header" href="#priorities">Priorities</a></h2>
<p>The static priority of each handler can be declared in the <code>task</code> attribute
using the <code>priority</code> argument. Tasks can have priorities in the range <code>1..=(1 &lt;&lt; NVIC_PRIO_BITS)</code> where <code>NVIC_PRIO_BITS</code> is a constant defined in the <code>device</code>
crate. When the <code>priority</code> argument is omitted, the priority is assumed to be
<code>1</code>. The <code>idle</code> task has a non-configurable static priority of <code>0</code>, the lowest priority.</p>
<blockquote>
<p>A higher number means a higher priority in RTIC, which is the opposite from what
Cortex-M does in the NVIC peripheral.<br />
Explicitly, this means that number <code>10</code> has a <strong>higher</strong> priority than number <code>9</code>.</p>
</blockquote>
<p>When several tasks are ready to be executed the one with highest static
priority will be executed first. Task prioritization can be observed in the
following scenario: an interrupt signal arrives during the execution of a low
priority task; the signal puts the higher priority task in the pending state.
The difference in priority results in the higher priority task preempting the
lower priority one: the execution of the lower priority task is suspended and
the higher priority task is executed to completion. Once the higher priority
task has terminated the lower priority task is resumed.</p>
<p>The following example showcases the priority based scheduling of tasks.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! examples/preempt.rs

#![no_main]
#![no_std]

use panic_semihosting as _;
use rtic::app;

#[app(device = lm3s6965)]
mod app {
    use cortex_m_semihosting::{debug, hprintln};
    use lm3s6965::Interrupt;

    #[init]
    fn init(_: init::Context) -&gt; (init::LateResources, init::Monotonics) {
        rtic::pend(Interrupt::GPIOA);

        (init::LateResources {}, init::Monotonics())
    }

    #[task(binds = GPIOA, priority = 1)]
    fn gpioa(_: gpioa::Context) {
        hprintln!(&quot;GPIOA - start&quot;).unwrap();
        rtic::pend(Interrupt::GPIOC);
        hprintln!(&quot;GPIOA - end&quot;).unwrap();
        debug::exit(debug::EXIT_SUCCESS);
    }

    #[task(binds = GPIOB, priority = 2)]
    fn gpiob(_: gpiob::Context) {
        hprintln!(&quot; GPIOB&quot;).unwrap();
    }

    #[task(binds = GPIOC, priority = 2)]
    fn gpioc(_: gpioc::Context) {
        hprintln!(&quot; GPIOC - start&quot;).unwrap();
        rtic::pend(Interrupt::GPIOB);
        hprintln!(&quot; GPIOC - end&quot;).unwrap();
    }
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-console">$ cargo run --example preempt
GPIOA - start
 GPIOC - start
 GPIOC - end
 GPIOB
GPIOA - end
</code></pre>
<p>Note that the task <code>gpiob</code> does <em>not</em> preempt task <code>gpioc</code> because its priority
is the <em>same</em> as <code>gpioc</code>'s. However, once <code>gpioc</code> returns, the execution of
task <code>gpiob</code> is prioritized over <code>gpioa</code> due to its higher priority. <code>gpioa</code>
is resumed only after <code>gpiob</code> returns.</p>
<p>One more note about priorities: choosing a priority higher than what the device
supports (that is <code>1 &lt;&lt; NVIC_PRIO_BITS</code>) will result in a compile error. Due to
limitations in the language, the error message is currently far from helpful: it
will say something along the lines of &quot;evaluation of constant value failed&quot; and
the span of the error will <em>not</em> point out to the problematic interrupt value --
we are sorry about this!</p>
<h1 id="resources"><a class="header" href="#resources">Resources</a></h1>
<p>The framework provides an abstraction to share data between any of the contexts
we saw in the previous section (task handlers, <code>init</code> and <code>idle</code>): resources.</p>
<p>Resources are data visible only to functions declared within the <code>#[app]</code>
module. The framework gives the user complete control over which context
can access which resource.</p>
<p>All resources are declared as a single <code>struct</code> within the <code>#[app]</code>
module. Each field in the structure corresponds to a different resource.
The <code>struct</code> must be annotated with the following attribute: <code>#[resources]</code>.</p>
<p>Resources can optionally be given an initial value using the <code>#[init]</code>
attribute. Resources that are not given an initial value are referred to as
<em>late</em> resources and are covered in more detail in a follow-up section in this
page.</p>
<p>Each context (task handler, <code>init</code> or <code>idle</code>) must declare the resources it
intends to access in its corresponding metadata attribute using the <code>resources</code>
argument. This argument takes a list of resource names as its value. The listed
resources are made available to the context under the <code>resources</code> field of the
<code>Context</code> structure.</p>
<p>The example application shown below contains two interrupt handlers that share access to a resource named <code>shared</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! examples/resource.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

use panic_semihosting as _;

#[rtic::app(device = lm3s6965)]
mod app {
    use cortex_m_semihosting::{debug, hprintln};
    use lm3s6965::Interrupt;

    #[resources]
    struct Resources {
        // A resource
        #[init(0)]
        shared: u32,
    }

    #[init]
    fn init(_: init::Context) -&gt; (init::LateResources, init::Monotonics) {
        rtic::pend(Interrupt::UART0);
        rtic::pend(Interrupt::UART1);

        (init::LateResources {}, init::Monotonics())
    }

    // `shared` cannot be accessed from this context
    #[idle]
    fn idle(_cx: idle::Context) -&gt; ! {
        debug::exit(debug::EXIT_SUCCESS);

        // error: no `resources` field in `idle::Context`
        // _cx.resources.shared += 1;

        loop {
            cortex_m::asm::nop();
        }
    }

    // `shared` can be accessed from this context
    // defaults to priority 1
    #[task(binds = UART0, resources = [shared])]
    fn uart0(mut cx: uart0::Context) {
        let shared = cx.resources.shared.lock(|shared| {
            *shared += 1;
            *shared
        });

        hprintln!(&quot;UART0: shared = {}&quot;, shared).unwrap();
    }

    // `shared` can be accessed from this context
    // explicitly set to priority 2
    #[task(binds = UART1, resources = [shared], priority = 2)]
    fn uart1(mut cx: uart1::Context) {
        let shared = cx.resources.shared.lock(|shared| {
            *shared += 1;
            *shared
        });

        hprintln!(&quot;UART1: shared = {}&quot;, shared).unwrap();
    }
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-console">$ cargo run --example resource
UART1: shared = 1
UART0: shared = 2
</code></pre>
<p>Note that the <code>shared</code> resource cannot be accessed from <code>idle</code>. Attempting to do so results in a compile error.</p>
<h2 id="lock"><a class="header" href="#lock"><code>lock</code></a></h2>
<p>Critical sections are required to access shared mutable data in a data race-free manner.</p>
<p>The <code>resources</code> field of the passed <code>Context</code> implements the <a href="by-example/../../../api/rtic/trait.Mutex.html"><code>Mutex</code></a> trait for each shared resource accessible to the task.</p>
<p>The only method on this trait, <a href="by-example/../../../api/rtic/trait.Mutex.html#method.lock"><code>lock</code></a>, runs its closure argument in a critical section.</p>
<p>The critical section created by the <code>lock</code> API is based on dynamic priorities: it temporarily raises the dynamic priority of the context to a <em>ceiling</em> priority that prevents other tasks from preempting the critical section. This synchronization protocol is known as the <a href="https://en.wikipedia.org/wiki/Priority_ceiling_protocol">Immediate Ceiling Priority Protocol
(ICPP)</a>, and complies with <a href="https://en.wikipedia.org/wiki/Stack_Resource_Policy">Stack Resource Policy(SRP)</a> based scheduling of RTIC.</p>
<p>In the example below we have three interrupt handlers with priorities ranging from one to three. The two handlers with the lower priorities contend for the <code>shared</code> resource and need to lock the resource for accessing the data. The highest priority handler, which do nat access the <code>shared</code> resource, is free to preempt the critical section created by the
lowest priority handler.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! examples/lock.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

use panic_semihosting as _;

#[rtic::app(device = lm3s6965)]
mod app {
    use cortex_m_semihosting::{debug, hprintln};
    use lm3s6965::Interrupt;

    #[resources]
    struct Resources {
        #[init(0)]
        shared: u32,
    }

    #[init]
    fn init(_: init::Context) -&gt; (init::LateResources, init::Monotonics) {
        rtic::pend(Interrupt::GPIOA);

        (init::LateResources {}, init::Monotonics())
    }

    // when omitted priority is assumed to be `1`
    #[task(binds = GPIOA, resources = [shared])]
    fn gpioa(mut c: gpioa::Context) {
        hprintln!(&quot;A&quot;).unwrap();

        // the lower priority task requires a critical section to access the data
        c.resources.shared.lock(|shared| {
            // data can only be modified within this critical section (closure)
            *shared += 1;

            // GPIOB will *not* run right now due to the critical section
            rtic::pend(Interrupt::GPIOB);

            hprintln!(&quot;B - shared = {}&quot;, *shared).unwrap();

            // GPIOC does not contend for `shared` so it's allowed to run now
            rtic::pend(Interrupt::GPIOC);
        });

        // critical section is over: GPIOB can now start

        hprintln!(&quot;E&quot;).unwrap();

        debug::exit(debug::EXIT_SUCCESS);
    }

    #[task(binds = GPIOB, priority = 2, resources = [shared])]
    fn gpiob(mut c: gpiob::Context) {
        // the higher priority task does still need a critical section
        let shared = c.resources.shared.lock(|shared| {
            *shared += 1;

            *shared
        });

        hprintln!(&quot;D - shared = {}&quot;, shared).unwrap();
    }

    #[task(binds = GPIOC, priority = 3)]
    fn gpioc(_: gpioc::Context) {
        hprintln!(&quot;C&quot;).unwrap();
    }
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-console">$ cargo run --example lock
A
B - shared = 1
C
D - shared = 2
E
</code></pre>
<h2 id="multi-lock"><a class="header" href="#multi-lock">Multi-lock</a></h2>
<p>As an extension to <code>lock</code>, and to reduce rightward drift, locks can be taken as tuples. The following examples shows this in use:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! examples/mutlilock.rs
//!
//! The multi-lock feature example.

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

use panic_semihosting as _;

#[rtic::app(device = lm3s6965)]
mod app {
    use cortex_m_semihosting::{debug, hprintln};
    use lm3s6965::Interrupt;

    #[resources]
    struct Resources {
        #[init(0)]
        shared1: u32,
        #[init(0)]
        shared2: u32,
        #[init(0)]
        shared3: u32,
    }

    #[init]
    fn init(_: init::Context) -&gt; (init::LateResources, init::Monotonics) {
        rtic::pend(Interrupt::GPIOA);

        (init::LateResources {}, init::Monotonics())
    }

    // when omitted priority is assumed to be `1`
    #[task(binds = GPIOA, resources = [shared1, shared2, shared3])]
    fn locks(c: locks::Context) {
        let mut s1 = c.resources.shared1;
        let mut s2 = c.resources.shared2;
        let mut s3 = c.resources.shared3;

        hprintln!(&quot;Multiple single locks&quot;).unwrap();
        s1.lock(|s1| {
            s2.lock(|s2| {
                s3.lock(|s3| {
                    *s1 += 1;
                    *s2 += 1;
                    *s3 += 1;

                    hprintln!(
                        &quot;Multiple single locks, s1: {}, s2: {}, s3: {}&quot;,
                        *s1,
                        *s2,
                        *s3
                    )
                    .unwrap();
                })
            })
        });

        hprintln!(&quot;Multilock!&quot;).unwrap();

        (s1, s2, s3).lock(|s1, s2, s3| {
            *s1 += 1;
            *s2 += 1;
            *s3 += 1;

            hprintln!(
                &quot;Multiple single locks, s1: {}, s2: {}, s3: {}&quot;,
                *s1,
                *s2,
                *s3
            )
            .unwrap();
        });

        debug::exit(debug::EXIT_SUCCESS);
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="late-resources"><a class="header" href="#late-resources">Late resources</a></h2>
<p>Late resources are resources that are not given an initial value at compile time using the <code>#[init]</code> attribute but instead are initialized at runtime using the <code>init::LateResources</code> values returned by the <code>init</code> function.</p>
<p>Late resources are useful e.g., to <em>move</em> (as in transferring the ownership of) peripherals initialized in <code>init</code> into tasks.</p>
<p>The example below uses late resources to establish a lockless, one-way channel between the <code>UART0</code> interrupt handler and the <code>idle</code> task. A single producer single consumer <a href="by-example/../../../api/heapless/spsc/struct.Queue.html"><code>Queue</code></a> is used as the channel. The queue is split into consumer and producer end points in <code>init</code> and then each end point is stored in a different resource; <code>UART0</code> owns the producer resource and <code>idle</code> owns the consumer resource.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! examples/late.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

use panic_semihosting as _;

#[rtic::app(device = lm3s6965)]
mod app {
    use cortex_m_semihosting::{debug, hprintln};
    use heapless::{
        consts::*,
        i,
        spsc::{Consumer, Producer, Queue},
    };
    use lm3s6965::Interrupt;

    // Late resources
    #[resources]
    struct Resources {
        p: Producer&lt;'static, u32, U4&gt;,
        c: Consumer&lt;'static, u32, U4&gt;,
    }

    #[init]
    fn init(_: init::Context) -&gt; (init::LateResources, init::Monotonics) {
        static mut Q: Queue&lt;u32, U4&gt; = Queue(i::Queue::new());

        let (p, c) = Q.split();

        // Initialization of late resources
        (init::LateResources { p, c }, init::Monotonics())
    }

    #[idle(resources = [c])]
    fn idle(mut c: idle::Context) -&gt; ! {
        loop {
            if let Some(byte) = c.resources.c.lock(|c| c.dequeue()) {
                hprintln!(&quot;received message: {}&quot;, byte).unwrap();

                debug::exit(debug::EXIT_SUCCESS);
            } else {
                rtic::pend(Interrupt::UART0);
            }
        }
    }

    #[task(binds = UART0, resources = [p])]
    fn uart0(mut c: uart0::Context) {
        c.resources.p.lock(|p| p.enqueue(42).unwrap());
    }
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-console">$ cargo run --example late
received message: 42
</code></pre>
<h2 id="only-shared-access"><a class="header" href="#only-shared-access">Only shared access</a></h2>
<p>By default the framework assumes that all tasks require exclusive access (<code>&amp;mut-</code>) to resources but it is possible to specify that a task only requires shared access (<code>&amp;-</code>) to a resource using the <code>&amp;resource_name</code> syntax in the <code>resources</code> list.</p>
<p>The advantage of specifying shared access (<code>&amp;-</code>) to a resource is that no locks are required to access the resource even if the resource is contended by several tasks running at different priorities. The downside is that the task only gets a shared reference (<code>&amp;-</code>) to the resource, limiting the operations it can perform on it, but where a shared reference is enough this approach reduces the number of required locks. In addition to simple immutable data, this shared access can be useful where the resource type safely implements interior mutability, with
appropriate locking or atomic operations of its own.</p>
<p>Note that in this release of RTIC it is not possible to request both exclusive access (<code>&amp;mut-</code>) and shared access (<code>&amp;-</code>) to the <em>same</em> resource from different tasks. Attempting to do so will result in a compile error.</p>
<p>In the example below a key (e.g. a cryptographic key) is loaded (or created) at runtime and then used from two tasks that run at different priorities without any kind of lock.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! examples/static.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

use panic_semihosting as _;

#[rtic::app(device = lm3s6965)]
mod app {
    use cortex_m_semihosting::{debug, hprintln};
    use lm3s6965::Interrupt;

    #[resources]
    struct Resources {
        key: u32,
    }

    #[init]
    fn init(_: init::Context) -&gt; (init::LateResources, init::Monotonics) {
        rtic::pend(Interrupt::UART0);
        rtic::pend(Interrupt::UART1);

        (init::LateResources { key: 0xdeadbeef }, init::Monotonics())
    }

    #[task(binds = UART0, resources = [&amp;key])]
    fn uart0(cx: uart0::Context) {
        let key: &amp;u32 = cx.resources.key;
        hprintln!(&quot;UART0(key = {:#x})&quot;, key).unwrap();

        debug::exit(debug::EXIT_SUCCESS);
    }

    #[task(binds = UART1, priority = 2, resources = [&amp;key])]
    fn uart1(cx: uart1::Context) {
        hprintln!(&quot;UART1(key = {:#x})&quot;, cx.resources.key).unwrap();
    }
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-console">$ cargo run --example only-shared-access
UART1(key = 0xdeadbeef)
UART0(key = 0xdeadbeef)
</code></pre>
<h2 id="lock-free-resource-access-of-mutable-resources"><a class="header" href="#lock-free-resource-access-of-mutable-resources">Lock-free resource access of mutable resources</a></h2>
<p>There exists two other options dealing with resources</p>
<ul>
<li><code>#[lock_free]</code>: there might be several tasks with the same priority
accessing the resource without critical section. Since tasks with the
same priority never can preempt another task on the same priority
this is safe.</li>
<li><code>#[task_local]</code>: there must be only one task using this resource,
similar to a <code>static mut</code> task local resource, but (optionally) set-up by init.</li>
</ul>
<h1 id="software-tasks"><a class="header" href="#software-tasks">Software tasks</a></h1>
<p>In addition to hardware tasks, which are invoked by the hardware in response to
hardware events, RTIC also supports <em>software</em> tasks which can be spawned by the
application from any execution context.</p>
<p>Software tasks can also be assigned priorities and, under the hood, are
dispatched from interrupt handlers. RTIC requires that free interrupts are
declared in the <code>dispatchers</code> app argument when using software tasks; some of these free
interrupts will be used to dispatch the software tasks. An advantage of software
tasks over hardware tasks is that many tasks can be mapped to a single interrupt
handler.</p>
<p>Software tasks are also declared using the <code>task</code> attribute but the <code>binds</code>
argument must be omitted.</p>
<p>The example below showcases three software tasks that run at 2 different
priorities. The three software tasks are mapped to 2 interrupts handlers.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! examples/task.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

use panic_semihosting as _;

#[rtic::app(device = lm3s6965, dispatchers = [SSI0, QEI0])]
mod app {
    use cortex_m_semihosting::{debug, hprintln};

    #[init]
    fn init(_: init::Context) -&gt; (init::LateResources, init::Monotonics) {
        foo::spawn().unwrap();

        (init::LateResources {}, init::Monotonics())
    }

    #[task]
    fn foo(_: foo::Context) {
        hprintln!(&quot;foo - start&quot;).unwrap();

        // spawns `bar` onto the task scheduler
        // `foo` and `bar` have the same priority so `bar` will not run until
        // after `foo` terminates
        bar::spawn().unwrap();

        hprintln!(&quot;foo - middle&quot;).unwrap();

        // spawns `baz` onto the task scheduler
        // `baz` has higher priority than `foo` so it immediately preempts `foo`
        baz::spawn().unwrap();

        hprintln!(&quot;foo - end&quot;).unwrap();
    }

    #[task]
    fn bar(_: bar::Context) {
        hprintln!(&quot;bar&quot;).unwrap();

        debug::exit(debug::EXIT_SUCCESS);
    }

    #[task(priority = 2)]
    fn baz(_: baz::Context) {
        hprintln!(&quot;baz&quot;).unwrap();
    }
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-console">$ cargo run --example task
foo - start
foo - middle
baz
foo - end
bar
</code></pre>
<h2 id="message-passing"><a class="header" href="#message-passing">Message passing</a></h2>
<p>The other advantage of software tasks is that messages can be passed to these
tasks when spawning them. The type of the message payload must be specified in
the signature of the task handler.</p>
<p>The example below showcases three tasks, two of them expect a message.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! examples/message.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

use panic_semihosting as _;

#[rtic::app(device = lm3s6965, dispatchers = [SSI0])]
mod app {
    use cortex_m_semihosting::{debug, hprintln};

    #[init]
    fn init(_: init::Context) -&gt; (init::LateResources, init::Monotonics) {
        foo::spawn(/* no message */).unwrap();

        (init::LateResources {}, init::Monotonics())
    }

    #[task]
    fn foo(_: foo::Context) {
        static mut COUNT: u32 = 0;

        hprintln!(&quot;foo&quot;).unwrap();

        bar::spawn(*COUNT).unwrap();
        *COUNT += 1;
    }

    #[task]
    fn bar(_: bar::Context, x: u32) {
        hprintln!(&quot;bar({})&quot;, x).unwrap();

        baz::spawn(x + 1, x + 2).unwrap();
    }

    #[task]
    fn baz(_: baz::Context, x: u32, y: u32) {
        hprintln!(&quot;baz({}, {})&quot;, x, y).unwrap();

        if x + y &gt; 4 {
            debug::exit(debug::EXIT_SUCCESS);
        }

        foo::spawn().unwrap();
    }
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-console">$ cargo run --example message
foo
bar(0)
baz(1, 2)
foo
bar(1)
baz(2, 3)
</code></pre>
<h2 id="capacity"><a class="header" href="#capacity">Capacity</a></h2>
<p>RTIC does <em>not</em> perform any form of heap-based memory allocation. The memory
required to store messages is statically reserved. By default the framework
minimizes the memory footprint of the application so each task has a message
&quot;capacity&quot; of 1: meaning that at most one message can be posted to the task
before it gets a chance to run. This default can be overridden for each task
using the <code>capacity</code> argument. This argument takes a positive integer that
indicates how many messages the task message buffer can hold.</p>
<p>The example below sets the capacity of the software task <code>foo</code> to 4. If the
capacity is not specified then the second <code>spawn.foo</code> call in <code>UART0</code> would
fail (panic).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! examples/capacity.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

use panic_semihosting as _;

#[rtic::app(device = lm3s6965, dispatchers = [SSI0])]
mod app {
    use cortex_m_semihosting::{debug, hprintln};
    use lm3s6965::Interrupt;

    #[init]
    fn init(_: init::Context) -&gt; (init::LateResources, init::Monotonics) {
        rtic::pend(Interrupt::UART0);

        (init::LateResources {}, init::Monotonics())
    }

    #[task(binds = UART0)]
    fn uart0(_: uart0::Context) {
        foo::spawn(0).unwrap();
        foo::spawn(1).unwrap();
        foo::spawn(2).unwrap();
        foo::spawn(3).unwrap();

        bar::spawn().unwrap();
    }

    #[task(capacity = 4)]
    fn foo(_: foo::Context, x: u32) {
        hprintln!(&quot;foo({})&quot;, x).unwrap();
    }

    #[task]
    fn bar(_: bar::Context) {
        hprintln!(&quot;bar&quot;).unwrap();

        debug::exit(debug::EXIT_SUCCESS);
    }
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-console">$ cargo run --example capacity
foo(0)
foo(1)
foo(2)
foo(3)
bar
</code></pre>
<h2 id="error-handling"><a class="header" href="#error-handling">Error handling</a></h2>
<p>The <code>spawn</code> API returns the <code>Err</code> variant when there's no space to send the
message. In most scenarios spawning errors are handled in one of two ways:</p>
<ul>
<li>
<p>Panicking, using <code>unwrap</code>, <code>expect</code>, etc. This approach is used to catch the
programmer   error (i.e. bug) of selecting a capacity that was too small. When
this panic is encountered during testing choosing a bigger capacity and
recompiling the program may fix the issue but sometimes it's necessary to dig
deeper and perform a timing analysis of the application to check if the
platform can deal with peak payload or if the processor needs to be replaced
with a faster one.</p>
</li>
<li>
<p>Ignoring the result. In soft real-time and non real-time applications it may
be OK to occasionally lose data or fail to respond to some events during event
bursts. In those scenarios silently letting a <code>spawn</code> call fail may be
acceptable.</p>
</li>
</ul>
<p>It should be noted that retrying a <code>spawn</code> call is usually the wrong approach as
this operation will likely never succeed in practice. Because there are only
context switches towards <em>higher</em> priority tasks retrying the <code>spawn</code> call of a
lower priority task will never let the scheduler dispatch said task meaning that
its message buffer will never be emptied. This situation is depicted in the
following snippet:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[rtic::app(..)]
mod app {
    #[init(spawn = [foo, bar])]
    fn init(cx: init::Context) {
        cx.spawn.foo().unwrap();
        cx.spawn.bar().unwrap();
    }

    #[task(priority = 2, spawn = [bar])]
    fn foo(cx: foo::Context) {
        // ..

        // the program will get stuck here
        while cx.spawn.bar(payload).is_err() {
            // retry the spawn call if it failed
        }
    }

    #[task(priority = 1)]
    fn bar(cx: bar::Context, payload: i32) {
        // ..
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="timer-queue"><a class="header" href="#timer-queue">Timer queue</a></h1>
<p>In contrast with the <code>spawn</code> API, which immediately spawns a software task onto
the scheduler, the <code>schedule</code> API can be used to schedule a task to run some
time in the future.</p>
<p>To use the <code>schedule</code> API a monotonic timer must be first defined using the
<code>monotonic</code> argument of the <code>#[app]</code> attribute. This argument takes a path to a
type that implements the <a href="by-example/../../../api/rtic/trait.Monotonic.html"><code>Monotonic</code></a> trait. The associated type, <code>Instant</code>, of
this trait represents a timestamp in arbitrary units and it's used extensively
in the <code>schedule</code> API -- it is suggested to model this type after <a href="https://doc.rust-lang.org/std/time/struct.Instant.html">the one in
the standard library</a>.</p>
<p>Although not shown in the trait definition (due to limitations in the trait /
type system) the subtraction of two <code>Instant</code>s should return some <code>Duration</code>
type (see <a href="https://doc.rust-lang.org/core/time/struct.Duration.html"><code>core::time::Duration</code></a>) and this <code>Duration</code> type must implement the
<code>TryInto&lt;u32&gt;</code> trait. The implementation of this trait must convert the
<code>Duration</code> value, which uses some arbitrary unit of time, into the &quot;system timer
(SYST) clock cycles&quot; time unit. The result of the conversion must be a 32-bit
integer. If the result of the conversion doesn't fit in a 32-bit number then the
operation must return an error, any error type.</p>
<p>For ARMv7+ targets the <code>rtic</code> crate provides a <code>Monotonic</code> implementation based
on the built-in CYCle CouNTer (CYCCNT). Note that this is a 32-bit timer clocked
at the frequency of the CPU and as such it is not suitable for tracking time
spans in the order of seconds.</p>
<p>When scheduling a task the (user-defined) <code>Instant</code> at which the task should be
executed must be passed as the first argument of the <code>schedule</code> invocation.</p>
<p>Additionally, the chosen <code>monotonic</code> timer must be configured and initialized
during the <code>#[init]</code> phase. Note that this is <em>also</em> the case if you choose to
use the <code>CYCCNT</code> provided by the <code>cortex-m-rtic</code> crate.</p>
<p>The example below schedules two tasks from <code>init</code>: <code>foo</code> and <code>bar</code>. <code>foo</code> is
scheduled to run 8 million clock cycles in the future. Next, <code>bar</code> is scheduled
to run 4 million clock cycles in the future. Thus <code>bar</code> runs before <code>foo</code> since
it was scheduled to run first.</p>
<blockquote>
<p><strong>IMPORTANT</strong>: The examples that use the <code>schedule</code> API or the <code>Instant</code>
abstraction will <strong>not</strong> properly work on QEMU because the Cortex-M cycle
counter functionality has not been implemented in <code>qemu-system-arm</code>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! examples/schedule.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

use panic_semihosting as _;

// NOTE: does NOT work on QEMU!
#[rtic::app(device = lm3s6965, dispatchers = [SSI0])]
mod app {
    use cortex_m_semihosting::hprintln;
    use dwt_systick_monotonic::DwtSystick;
    use rtic::time::duration::Seconds;

    #[monotonic(binds = SysTick, default = true)]
    type MyMono = DwtSystick&lt;8_000_000&gt;; // 8 MHz

    #[init()]
    fn init(cx: init::Context) -&gt; (init::LateResources, init::Monotonics) {
        let mut dcb = cx.core.DCB;
        let dwt = cx.core.DWT;
        let systick = cx.core.SYST;

        let mono = DwtSystick::new(&amp;mut dcb, dwt, systick, 8_000_000);

        hprintln!(&quot;init&quot;).unwrap();

        // Schedule `foo` to run 1 second in the future
        foo::spawn_after(Seconds(1_u32)).unwrap();

        // Schedule `bar` to run 2 seconds in the future
        bar::spawn_after(Seconds(2_u32)).unwrap();

        (init::LateResources {}, init::Monotonics(mono))
    }

    #[task]
    fn foo(_: foo::Context) {
        hprintln!(&quot;foo&quot;).unwrap();
    }

    #[task]
    fn bar(_: bar::Context) {
        hprintln!(&quot;bar&quot;).unwrap();
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Running the program on real hardware produces the following output in the
console:</p>
<pre><code class="language-text">init @ Instant(0)
bar  @ Instant(4000236)
foo  @ Instant(8000173)
</code></pre>
<p>When the <code>schedule</code> API is being used the runtime internally uses the <code>SysTick</code>
interrupt handler and the system timer peripheral (<code>SYST</code>) so neither can be
used by the application. This is accomplished by changing the type of
<code>init::Context.core</code> from <code>cortex_m::Peripherals</code> to <code>rtic::Peripherals</code>. The
latter structure contains all the fields of the former minus the <code>SYST</code> one.</p>
<h2 id="periodic-tasks"><a class="header" href="#periodic-tasks">Periodic tasks</a></h2>
<p>Software tasks have access to the <code>Instant</code> at which they were scheduled to run
through the <code>scheduled</code> variable. This information and the <code>schedule</code> API can be
used to implement periodic tasks as shown in the example below.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! examples/periodic.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

use panic_semihosting as _;

// NOTE: does NOT work on QEMU!
#[rtic::app(device = lm3s6965, dispatchers = [SSI0])]
mod app {
    use dwt_systick_monotonic::DwtSystick;
    use rtic::time::duration::Seconds;

    #[monotonic(binds = SysTick, default = true)]
    type MyMono = DwtSystick&lt;8_000_000&gt;; // 8 MHz

    #[init]
    fn init(cx: init::Context) -&gt; (init::LateResources, init::Monotonics) {
        let mut dcb = cx.core.DCB;
        let dwt = cx.core.DWT;
        let systick = cx.core.SYST;

        let mono = DwtSystick::new(&amp;mut dcb, dwt, systick, 8_000_000);

        foo::spawn_after(Seconds(1_u32)).unwrap();

        (init::LateResources {}, init::Monotonics(mono))
    }

    #[task]
    fn foo(_cx: foo::Context) {
        // Periodic
        foo::spawn_after(Seconds(1_u32)).unwrap();
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This is the output produced by the example. Note that there is zero drift /
jitter even though <code>schedule.foo</code> was invoked at the <em>end</em> of <code>foo</code>. Using
<code>Instant::now</code> instead of <code>scheduled</code> would have resulted in drift / jitter.</p>
<pre><code class="language-text">foo(scheduled = Instant(8000000), now = Instant(8000196))
foo(scheduled = Instant(16000000), now = Instant(16000196))
foo(scheduled = Instant(24000000), now = Instant(24000196))
</code></pre>
<h2 id="baseline"><a class="header" href="#baseline">Baseline</a></h2>
<p>For the tasks scheduled from <code>init</code> we have exact information about their
<code>scheduled</code> time. For hardware tasks there's no <code>scheduled</code> time because these
tasks are asynchronous in nature. For hardware tasks the runtime provides a
<code>start</code> time, which indicates the time at which the task handler started
executing.</p>
<p>Note that <code>start</code> is <strong>not</strong> equal to the arrival time of the event that fired
the task. Depending on the priority of the task and the load of the system the
<code>start</code> time could be very far off from the event arrival time.</p>
<p>What do you think will be the value of <code>scheduled</code> for software tasks that are
<em>spawned</em> instead of scheduled? The answer is that spawned tasks inherit the
<em>baseline</em> time of the context that spawned it. The baseline of hardware tasks
is their <code>start</code> time, the baseline of software tasks is their <code>scheduled</code> time
and the baseline of <code>init</code> is the system start time or time zero
(<code>Instant::zero()</code>). <code>idle</code> doesn't really have a baseline but tasks spawned
from it will use <code>Instant::now()</code> as their baseline time.</p>
<p>The example below showcases the different meanings of the <em>baseline</em>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{{#include ../../../../examples/baseline.rs}}
<span class="boring">}
</span></code></pre></pre>
<p>Running the program on real hardware produces the following output in the console:</p>
<pre><code class="language-text">init(baseline = Instant(0))
foo(baseline = Instant(0))
UART0(baseline = Instant(904))
foo(baseline = Instant(904))
</code></pre>
<h1 id="types-send-and-sync"><a class="header" href="#types-send-and-sync">Types, Send and Sync</a></h1>
<p>Every function within the <code>app</code> module has a <code>Context</code> structure as its
first parameter. All the fields of these structures have predictable,
non-anonymous types so you can write plain functions that take them as arguments.</p>
<p>The API reference specifies how these types are generated from the input. You
can also generate documentation for your binary crate (<code>cargo doc --bin &lt;name&gt;</code>);
in the documentation you'll find <code>Context</code> structs (e.g. <code>init::Context</code> and
<code>idle::Context</code>).</p>
<p>The example below shows the different types generates by the <code>app</code> attribute.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! examples/types.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

use panic_semihosting as _;

#[rtic::app(device = lm3s6965, peripherals = true, dispatchers = [SSI0])]
mod app {
    use cortex_m_semihosting::debug;
    use dwt_systick_monotonic::DwtSystick;

    #[monotonic(binds = SysTick, default = true)]
    type MyMono = DwtSystick&lt;8_000_000&gt;; // 8 MHz

    #[resources]
    struct Resources {
        #[init(0)]
        shared: u32,
    }

    #[init]
    fn init(cx: init::Context) -&gt; (init::LateResources, init::Monotonics) {
        let _: cortex_m::Peripherals = cx.core;
        let _: lm3s6965::Peripherals = cx.device;

        debug::exit(debug::EXIT_SUCCESS);

        let mut dcb = cx.core.DCB;
        let dwt = cx.core.DWT;
        let systick = cx.core.SYST;

        let mono = DwtSystick::new(&amp;mut dcb, dwt, systick, 8_000_000);

        (init::LateResources {}, init::Monotonics(mono))
    }

    #[idle]
    fn idle(_: idle::Context) -&gt; ! {
        loop {
            cortex_m::asm::nop();
        }
    }

    #[task(binds = UART0, resources = [shared])]
    fn uart0(cx: uart0::Context) {
        let _: resources::shared = cx.resources.shared;
    }

    #[task(priority = 2, resources = [shared])]
    fn foo(cx: foo::Context) {
        let _: resources::shared = cx.resources.shared;
        let _: foo::Resources = cx.resources;
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="send"><a class="header" href="#send"><code>Send</code></a></h2>
<p><a href="https://doc.rust-lang.org/core/marker/trait.Send.html"><code>Send</code></a> is a marker trait for &quot;types that can be transferred across thread
boundaries&quot;, according to its definition in <code>core</code>. In the context of RTIC the
<code>Send</code> trait is only required where it's possible to transfer a value between
tasks that run at <em>different</em> priorities. This occurs in a few places: in
message passing, in shared resources and in the initialization of late
resources.</p>
<p>The <code>app</code> attribute will enforce that <code>Send</code> is implemented where required so
you don't need to worry much about it. Currently all types that are passed need
to be <code>Send</code> in RTIC, however this restriction might be relaxed in the future.</p>
<h2 id="sync"><a class="header" href="#sync"><code>Sync</code></a></h2>
<p>Similarly, <a href="https://doc.rust-lang.org/core/marker/trait.Sync.html"><code>Sync</code></a> is a marker trait for &quot;types for which it is safe to share
references between threads&quot;, according to its definition in <code>core</code>. In the
context of RTIC the <code>Sync</code> trait is only required where it's possible for two,
or more, tasks that run at different priorities and may get a shared reference
(<code>&amp;-</code>) to a resource. This only occurs with shared access (<code>&amp;-</code>) resources.</p>
<p>The <code>app</code> attribute will enforce that <code>Sync</code> is implemented where required but
it's important to know where the <code>Sync</code> bound is not required: shared access
(<code>&amp;-</code>) resources contended by tasks that run at the <em>same</em> priority.</p>
<p>The example below shows where a type that doesn't implement <code>Sync</code> can be used.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! `examples/not-sync.rs`

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

use core::marker::PhantomData;
use panic_semihosting as _;

pub struct NotSync {
    _0: PhantomData&lt;*const ()&gt;,
}

#[rtic::app(device = lm3s6965, dispatchers = [SSI0])]
mod app {
    use super::NotSync;
    use core::marker::PhantomData;
    use cortex_m_semihosting::debug;

    #[resources]
    struct Resources {
        #[init(NotSync { _0: PhantomData })]
        shared: NotSync,
    }

    #[init]
    fn init(_: init::Context) -&gt; (init::LateResources, init::Monotonics) {
        debug::exit(debug::EXIT_SUCCESS);

        (init::LateResources {}, init::Monotonics())
    }

    #[task(resources = [&amp;shared])]
    fn foo(c: foo::Context) {
        let _: &amp;NotSync = c.resources.shared;
    }

    #[task(resources = [&amp;shared])]
    fn bar(c: bar::Context) {
        let _: &amp;NotSync = c.resources.shared;
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="starting-a-new-project"><a class="header" href="#starting-a-new-project">Starting a new project</a></h1>
<p>Now that you have learned about the main features of the RTIC framework you can
try it out on your hardware by following these instructions.</p>
<ol>
<li>Instantiate the <a href="https://github.com/rust-embedded/cortex-m-quickstart#cortex-m-quickstart"><code>cortex-m-quickstart</code></a> template.</li>
</ol>
<pre><code class="language-console">$ # for example using `cargo-generate`
$ cargo generate \
    --git https://github.com/rust-embedded/cortex-m-quickstart \
    --name app

$ # follow the rest of the instructions
</code></pre>
<ol start="2">
<li>Add a peripheral access crate (PAC) that was generated using <a href="https://crates.io/crates/svd2rust"><code>svd2rust</code></a>
<strong>v0.14.x</strong>, or a board support crate that depends on one such PAC as a
dependency. Make sure that the <code>rt</code> feature of the crate is enabled.</li>
</ol>
<p>In this example, I'll use the <a href="https://crates.io/crates/lm3s6965"><code>lm3s6965</code></a> device crate. This device crate
doesn't have an <code>rt</code> Cargo feature; that feature is always enabled.</p>
<p>This device crate provides a linker script with the memory layout of the target
device so <code>memory.x</code> and <code>build.rs</code> need to be removed.</p>
<pre><code class="language-console">$ cargo add lm3s6965 --vers 0.1.3

$ rm memory.x build.rs
</code></pre>
<ol start="3">
<li>Add the <code>cortex-m-rtic</code> crate as a dependency.</li>
</ol>
<pre><code class="language-console">$ cargo add cortex-m-rtic --allow-prerelease
</code></pre>
<ol start="4">
<li>Write your RTIC application.</li>
</ol>
<p>Here I'll use the <code>init</code> example from the <code>cortex-m-rtic</code> crate.</p>
<p>The examples are found in the <code>examples</code> folder, and the contents
of <code>init.rs</code> is shown here:</p>
<pre><code class="language-console">//! examples/init.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

use panic_semihosting as _;

#[rtic::app(device = lm3s6965, peripherals = true)]
mod app {
    use cortex_m_semihosting::{debug, hprintln};

    #[init]
    fn init(cx: init::Context) -&gt; (init::LateResources, init::Monotonics) {
        static mut X: u32 = 0;

        // Cortex-M peripherals
        let _core: cortex_m::Peripherals = cx.core;

        // Device specific peripherals
        let _device: lm3s6965::Peripherals = cx.device;

        // Safe access to local `static mut` variable
        let _x: &amp;'static mut u32 = X;

        // Access to the critical section token,
        // to indicate that this is a critical seciton
        let _cs_token: bare_metal::CriticalSection = cx.cs;

        hprintln!(&quot;init&quot;).unwrap();

        debug::exit(debug::EXIT_SUCCESS);

        (init::LateResources {}, init::Monotonics())
    }
}
</code></pre>
<p>The <code>init</code> example uses the <code>lm3s6965</code> device. Remember to adjust the <code>device</code>
argument in the app macro attribute to match the path of your PAC crate, if
different, and add peripherals or other arguments if needed. Although aliases
can be used, this needs to be a full path (from the crate root). For many
devices, it is common for the HAL implementation crate (aliased as <code>hal</code>) or
Board Support crate to re-export the PAC as <code>pac</code>, leading to a pattern similar
to the below:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use abcd123_hal as hal;
//...

#[rtic::app(device = crate::hal::pac, peripherals = true, monotonic = rtic::cyccnt::CYCCNT)]
mod app { /*...*/ }
<span class="boring">}
</span></code></pre></pre>
<p>The <code>init</code> example also depends on the <code>panic-semihosting</code> crate:</p>
<pre><code class="language-console">$ cargo add panic-semihosting
</code></pre>
<ol start="5">
<li>Build it, flash it and run it.</li>
</ol>
<pre><code class="language-console">$ # NOTE: I have uncommented the `runner` option in `.cargo/config`
$ cargo run
init
</code></pre>
<h1 id="tips--tricks"><a class="header" href="#tips--tricks">Tips &amp; tricks</a></h1>
<h2 id="generics"><a class="header" href="#generics">Generics</a></h2>
<p>All resource proxies implement the <code>rtic::Mutex</code> trait.
If a resource does not implement this, one can wrap it in the <a href="by-example/../../../api/rtic/struct.Exclusive.html"><code>rtic::Exclusive</code></a>
newtype which does implement the <code>Mutex</code> trait. With the help of this newtype
one can write a generic function that operates on generic resources and call it
from different tasks to perform some operation on the same set of resources.
Here's one such example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! examples/generics.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

use cortex_m_semihosting::hprintln;
use panic_semihosting as _;
use rtic::Mutex;

#[rtic::app(device = lm3s6965)]
mod app {
    use cortex_m_semihosting::{debug, hprintln};
    use lm3s6965::Interrupt;

    #[resources]
    struct Resources {
        #[init(0)]
        shared: u32,
    }

    #[init]
    fn init(_: init::Context) -&gt; (init::LateResources, init::Monotonics) {
        rtic::pend(Interrupt::UART0);
        rtic::pend(Interrupt::UART1);

        (init::LateResources {}, init::Monotonics())
    }

    #[task(binds = UART0, resources = [shared])]
    fn uart0(c: uart0::Context) {
        static mut STATE: u32 = 0;

        hprintln!(&quot;UART0(STATE = {})&quot;, *STATE).unwrap();

        // second argument has type `resources::shared`
        super::advance(STATE, c.resources.shared);

        rtic::pend(Interrupt::UART1);

        debug::exit(debug::EXIT_SUCCESS);
    }

    #[task(binds = UART1, priority = 2, resources = [shared])]
    fn uart1(c: uart1::Context) {
        static mut STATE: u32 = 0;

        hprintln!(&quot;UART1(STATE = {})&quot;, *STATE).unwrap();

        // second argument has type `resources::shared`
        super::advance(STATE, c.resources.shared);
    }
}

// the second parameter is generic: it can be any type that implements the `Mutex` trait
fn advance(state: &amp;mut u32, mut shared: impl Mutex&lt;T = u32&gt;) {
    *state += 1;

    let (old, new) = shared.lock(|shared: &amp;mut u32| {
        let old = *shared;
        *shared += *state;
        (old, *shared)
    });

    hprintln!(&quot;shared: {} -&gt; {}&quot;, old, new).unwrap();
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-console">$ cargo run --example generics
UART1(STATE = 0)
shared: 0 -&gt; 1
UART0(STATE = 0)
shared: 1 -&gt; 2
UART1(STATE = 1)
shared: 2 -&gt; 4
</code></pre>
<h2 id="conditional-compilation"><a class="header" href="#conditional-compilation">Conditional compilation</a></h2>
<p>You can use conditional compilation (<code>#[cfg]</code>) on resources (the fields of
<code>#[resources] struct Resources</code>) and tasks (the <code>fn</code> items).
The effect of using <code>#[cfg]</code> attributes is that the resource / task
will <em>not</em> be available through the corresponding <code>Context</code> <code>struct</code>
if the condition doesn't hold.</p>
<p>The example below logs a message whenever the <code>foo</code> task is spawned, but only if
the program has been compiled using the <code>dev</code> profile.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! examples/cfg.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

use panic_semihosting as _;

#[rtic::app(device = lm3s6965, dispatchers = [SSI0, QEI0])]
mod app {
    use cortex_m_semihosting::debug;
    #[cfg(debug_assertions)]
    use cortex_m_semihosting::hprintln;

    #[resources]
    struct Resources {
        #[cfg(debug_assertions)] // &lt;- `true` when using the `dev` profile
        #[init(0)]
        count: u32,
    }

    #[init]
    fn init(_: init::Context) -&gt; (init::LateResources, init::Monotonics) {
        foo::spawn().unwrap();
        foo::spawn().unwrap();

        (init::LateResources {}, init::Monotonics())
    }

    #[idle]
    fn idle(_: idle::Context) -&gt; ! {
        debug::exit(debug::EXIT_SUCCESS);

        loop {
            cortex_m::asm::nop();
        }
    }

    #[task(capacity = 2, resources = [count])]
    fn foo(mut _cx: foo::Context) {
        #[cfg(debug_assertions)]
        {
            _cx.resources.count.lock(|count| *count += 1);

            log::spawn(_cx.resources.count.lock(|count| *count)).unwrap();
        }

        // this wouldn't compile in `release` mode
        // *_cx.resources.count += 1;

        // ..
    }

    #[cfg(debug_assertions)]
    #[task(capacity = 2)]
    fn log(_: log::Context, n: u32) {
        hprintln!(
            &quot;foo has been called {} time{}&quot;,
            n,
            if n == 1 { &quot;&quot; } else { &quot;s&quot; }
        )
        .ok();
    }
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-console">$ cargo run --example cfg --release

$ cargo run --example cfg
foo has been called 1 time
foo has been called 2 times
</code></pre>
<h2 id="running-tasks-from-ram"><a class="header" href="#running-tasks-from-ram">Running tasks from RAM</a></h2>
<p>The main goal of moving the specification of RTIC applications to attributes in
RTIC v0.4.0 was to allow inter-operation with other attributes. For example, the
<code>link_section</code> attribute can be applied to tasks to place them in RAM; this can
improve performance in some cases.</p>
<blockquote>
<p><strong>IMPORTANT</strong>: In general, the <code>link_section</code>, <code>export_name</code> and <code>no_mangle</code>
attributes are very powerful but also easy to misuse. Incorrectly using any of
these attributes can cause undefined behavior; you should always prefer to use
safe, higher level attributes around them like <code>cortex-m-rt</code>'s <code>interrupt</code> and
<code>exception</code> attributes.</p>
<p>In the particular case of RAM functions there's no
safe abstraction for it in <code>cortex-m-rt</code> v0.6.5 but there's an <a href="https://github.com/rust-embedded/cortex-m-rt/pull/100">RFC</a> for
adding a <code>ramfunc</code> attribute in a future release.</p>
</blockquote>
<p>The example below shows how to place the higher priority task, <code>bar</code>, in RAM.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! examples/ramfunc.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

use panic_semihosting as _;

#[rtic::app(
    device = lm3s6965,
    dispatchers = [
        UART0,
        #[link_section = &quot;.data.UART1&quot;]
        UART1
    ])
]
mod app {
    use cortex_m_semihosting::{debug, hprintln};

    #[init]
    fn init(_: init::Context) -&gt; (init::LateResources, init::Monotonics) {
        foo::spawn().unwrap();

        (init::LateResources {}, init::Monotonics())
    }

    #[inline(never)]
    #[task]
    fn foo(_: foo::Context) {
        hprintln!(&quot;foo&quot;).unwrap();

        debug::exit(debug::EXIT_SUCCESS);
    }

    // run this task from RAM
    #[inline(never)]
    #[link_section = &quot;.data.bar&quot;]
    #[task(priority = 2)]
    fn bar(_: bar::Context) {
        foo::spawn().unwrap();
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Running this program produces the expected output.</p>
<pre><code class="language-console">$ cargo run --example ramfunc
foo
</code></pre>
<p>One can look at the output of <code>cargo-nm</code> to confirm that <code>bar</code> ended in RAM
(<code>0x2000_0000</code>), whereas <code>foo</code> ended in Flash (<code>0x0000_0000</code>).</p>
<pre><code class="language-console">$ cargo nm --example ramfunc --release | grep ' foo::'
00000162 t ramfunc::foo::h30e7789b08c08e19
</code></pre>
<pre><code class="language-console">$ cargo nm --example ramfunc --release | grep ' bar::'
20000000 t ramfunc::bar::h9d6714fe5a3b0c89
</code></pre>
<h2 id="indirection-for-faster-message-passing"><a class="header" href="#indirection-for-faster-message-passing">Indirection for faster message passing</a></h2>
<p>Message passing always involves copying the payload from the sender into a
static variable and then from the static variable into the receiver. Thus
sending a large buffer, like a <code>[u8; 128]</code>, as a message involves two expensive
<code>memcpy</code>s. To minimize the message passing overhead one can use indirection:
instead of sending the buffer by value, one can send an owning pointer into the
buffer.</p>
<p>One can use a global allocator to achieve indirection (<code>alloc::Box</code>,
<code>alloc::Rc</code>, etc.), which requires using the nightly channel as of Rust v1.37.0,
or one can use a statically allocated memory pool like <a href="https://docs.rs/heapless/0.5.0/heapless/pool/index.html"><code>heapless::Pool</code></a>.</p>
<p>Here's an example where <code>heapless::Pool</code> is used to &quot;box&quot; buffers of 128 bytes.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! examples/pool.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

use heapless::{
    pool,
    pool::singleton::{Box, Pool},
};
use panic_semihosting as _;
use rtic::app;

// Declare a pool of 128-byte memory blocks
pool!(P: [u8; 128]);

#[app(device = lm3s6965, dispatchers = [SSI0, QEI0])]
mod app {
    use crate::{Box, Pool};
    use cortex_m_semihosting::{debug, hprintln};
    use lm3s6965::Interrupt;

    // Import the memory pool into scope
    use super::P;

    #[init]
    fn init(_: init::Context) -&gt; (init::LateResources, init::Monotonics) {
        static mut MEMORY: [u8; 512] = [0; 512];

        // Increase the capacity of the memory pool by ~4
        P::grow(MEMORY);

        rtic::pend(Interrupt::I2C0);

        (init::LateResources {}, init::Monotonics())
    }

    #[task(binds = I2C0, priority = 2)]
    fn i2c0(_: i2c0::Context) {
        // claim a memory block, leave it uninitialized and ..
        let x = P::alloc().unwrap().freeze();

        // .. send it to the `foo` task
        foo::spawn(x).ok().unwrap();

        // send another block to the task `bar`
        bar::spawn(P::alloc().unwrap().freeze()).ok().unwrap();
    }

    #[task]
    fn foo(_: foo::Context, x: Box&lt;P&gt;) {
        hprintln!(&quot;foo({:?})&quot;, x.as_ptr()).unwrap();

        // explicitly return the block to the pool
        drop(x);

        debug::exit(debug::EXIT_SUCCESS);
    }

    #[task(priority = 2)]
    fn bar(_: bar::Context, x: Box&lt;P&gt;) {
        hprintln!(&quot;bar({:?})&quot;, x.as_ptr()).unwrap();

        // this is done automatically so we can omit the call to `drop`
        // drop(x);
    }
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-console">$ cargo run --example pool
bar(0x2000008c)
foo(0x20000110)
</code></pre>
<h2 id="inspecting-the-expanded-code"><a class="header" href="#inspecting-the-expanded-code">Inspecting the expanded code</a></h2>
<p><code>#[rtic::app]</code> is a procedural macro that produces support code. If for some
reason you need to inspect the code generated by this macro you have two
options:</p>
<p>You can inspect the file <code>rtic-expansion.rs</code> inside the <code>target</code> directory. This
file contains the expansion of the <code>#[rtic::app]</code> item (not your whole program!)
of the <em>last built</em> (via <code>cargo build</code> or <code>cargo check</code>) RTIC application. The
expanded code is not pretty printed by default so you'll want to run <code>rustfmt</code>
on it before you read it.</p>
<pre><code class="language-console">$ cargo build --example foo

$ rustfmt target/rtic-expansion.rs

$ tail target/rtic-expansion.rs
</code></pre>
<pre><pre class="playground"><code class="language-rust">#[doc = r&quot; Implementation details&quot;]
mod app {
    #[doc = r&quot; Always include the device crate which contains the vector table&quot;]
    use lm3s6965 as _;
    #[no_mangle]
    unsafe extern &quot;C&quot; fn main() -&gt; ! {
        rtic::export::interrupt::disable();
        let mut core: rtic::export::Peripherals = core::mem::transmute(());
        core.SCB.scr.modify(|r| r | 1 &lt;&lt; 1);
        rtic::export::interrupt::enable();
        loop {
            rtic::export::wfi()
        }
    }
}
</code></pre></pre>
<p>Or, you can use the <a href="https://crates.io/crates/cargo-expand"><code>cargo-expand</code></a> sub-command. This sub-command will expand
<em>all</em> the macros, including the <code>#[rtic::app]</code> attribute, and modules in your
crate and print the output to the console.</p>
<pre><code class="language-console">$ # produces the same output as before
$ cargo expand --example smallest | tail
</code></pre>
<h2 id="resource-de-structure-ing"><a class="header" href="#resource-de-structure-ing">Resource de-structure-ing</a></h2>
<p>When having a task taking multiple resources it can help in readability to split
up the resource struct. Here are two examples on how this can be done:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! examples/destructure.rs

#![deny(unsafe_code)]
#![deny(warnings)]
#![no_main]
#![no_std]

use panic_semihosting as _;

#[rtic::app(device = lm3s6965)]
mod app {
    use cortex_m_semihosting::hprintln;
    use lm3s6965::Interrupt;

    #[resources]
    struct Resources {
        // Some resources to work with
        #[init(0)]
        a: u32,
        #[init(0)]
        b: u32,
        #[init(0)]
        c: u32,
    }

    #[init]
    fn init(_: init::Context) -&gt; (init::LateResources, init::Monotonics) {
        rtic::pend(Interrupt::UART0);
        rtic::pend(Interrupt::UART1);

        (init::LateResources {}, init::Monotonics())
    }

    // Direct destructure
    #[task(binds = UART0, resources = [&amp;a, &amp;b, &amp;c])]
    fn uart0(cx: uart0::Context) {
        let a = cx.resources.a;
        let b = cx.resources.b;
        let c = cx.resources.c;

        hprintln!(&quot;UART0: a = {}, b = {}, c = {}&quot;, a, b, c).unwrap();
    }

    // De-structure-ing syntax
    #[task(binds = UART1, resources = [&amp;a, &amp;b, &amp;c])]
    fn uart1(cx: uart1::Context) {
        let uart1::Resources { a, b, c } = cx.resources;

        hprintln!(&quot;UART0: a = {}, b = {}, c = {}&quot;, a, b, c).unwrap();
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="migration-guides"><a class="header" href="#migration-guides">Migration Guides</a></h1>
<p>This section describes how to migrate between different version of RTIC.
It also acts as a comparing reference between versions.</p>
<h1 id="migrating-from-v05x-to-v060"><a class="header" href="#migrating-from-v05x-to-v060">Migrating from v0.5.x to v0.6.0</a></h1>
<p>This section describes how to upgrade from v0.5.x to v0.6.0 of the RTIC framework.</p>
<h2 id="cargotoml---version-bump"><a class="header" href="#cargotoml---version-bump"><code>Cargo.toml</code> - version bump</a></h2>
<p>Change the version of <code>cortex-m-rtic</code> to <code>&quot;0.6.0&quot;</code>.</p>
<h2 id="mod-instead-of-const"><a class="header" href="#mod-instead-of-const"><code>mod</code> instead of <code>const</code></a></h2>
<p>With the support of attributes on modules the <code>const APP</code> workaround is not needed.</p>
<p>Change</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[rtic::app(/* .. */)]
const APP: () = {
  [code here]
};
<span class="boring">}
</span></code></pre></pre>
<p>into</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[rtic::app(/* .. */)]
mod app {
  [code here]
}
<span class="boring">}
</span></code></pre></pre>
<p>Now that a regular Rust module is used it means it is possible to have custom
user code within that module.
Additionally, it means that <code>use</code>-statements for resources etc may be required.</p>
<h2 id="move-dispatchers-from-extern-c-to-app-arguments"><a class="header" href="#move-dispatchers-from-extern-c-to-app-arguments">Move Dispatchers from <code>extern &quot;C&quot;</code> to app arguments.</a></h2>
<p>Change</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[rtic::app(/* .. */)]
const APP: () = {
    [code here]

    // RTIC requires that unused interrupts are declared in an extern block when
    // using software tasks; these free interrupts will be used to dispatch the
    // software tasks.
    extern &quot;C&quot; {
        fn SSI0();
        fn QEI0();
    }
};
<span class="boring">}
</span></code></pre></pre>
<p>into</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[rtic::app(/* .. */, dispatchers = [SSI0, QEI0])]
mod app {
  [code here]
}
<span class="boring">}
</span></code></pre></pre>
<p>This works also for ram functions, see examples/ramfunc.rs</p>
<h2 id="init-always-returns-late-resources"><a class="header" href="#init-always-returns-late-resources">Init always returns late resources</a></h2>
<p>In order to make the API more symmetric the #[init]-task always returns a late resource.</p>
<p>From this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[rtic::app(device = lm3s6965)]
mod app {
    #[init]
    fn init(_: init::Context) {
        rtic::pend(Interrupt::UART0);
    }

    // [more code]
}
<span class="boring">}
</span></code></pre></pre>
<p>to this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[rtic::app(device = lm3s6965)]
mod app {
    #[init]
    fn init(_: init::Context) -&gt; init::LateResources {
        rtic::pend(Interrupt::UART0);

        init::LateResources {}
    }

    // [more code]
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="resources-struct---resources"><a class="header" href="#resources-struct---resources">Resources struct - <code>#[resources]</code></a></h2>
<p>Previously the RTIC resources had to be in in a struct named exactly &quot;Resources&quot;:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Resources {
    // Resources defined in here
}
<span class="boring">}
</span></code></pre></pre>
<p>With RTIC v0.6.0 the resources struct is annotated similarly like
<code>#[task]</code>, <code>#[init]</code>, <code>#[idle]</code>: with an attribute <code>#[resources]</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[resources]
struct Resources {
    // Resources defined in here
}
<span class="boring">}
</span></code></pre></pre>
<p>In fact, the name of the struct is now up to the developer:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[resources]
struct Whateveryouwant {
    // Resources defined in here
}
<span class="boring">}
</span></code></pre></pre>
<p>would work equally well.</p>
<h2 id="spawnschedule-from-anywhere"><a class="header" href="#spawnschedule-from-anywhere">Spawn/schedule from anywhere</a></h2>
<p>With the new &quot;spawn/schedule from anywhere&quot;, old code such as:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[task(spawn = [bar])]
fn foo(cx: foo::Context) {
    cx.spawn.bar().unwrap();
}

#[task(schedule = [bar])]
fn bar(cx: bar::Context) {
    cx.schedule.foo(/* ... */).unwrap();
}
<span class="boring">}
</span></code></pre></pre>
<p>Will now be written as:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[task]
fn foo(_c: foo::Context) {
    bar::spawn().unwrap();
}

#[task]
fn bar(_c: bar::Context) {
    foo::schedule(/* ... */).unwrap();
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that the attributes <code>spawn</code> and <code>schedule</code> are no longer needed.</p>
<h2 id="symmetric-locks"><a class="header" href="#symmetric-locks">Symmetric locks</a></h2>
<p>Now RTIC utilizes symmetric locks, this means that the <code>lock</code> method need to be used for all resource access. In old code one could do the following as the high priority task has exclusive access to the resource:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[task(priority = 2, resources = [r])]
fn foo(cx: foo::Context) {
    cx.resources.r = /* ... */;
}

#[task(resources = [r])]
fn bar(cx: bar::Context) {
    cx.resources.r.lock(|r| r = /* ... */);
}
<span class="boring">}
</span></code></pre></pre>
<p>And with symmetric locks one needs to use locks in both tasks:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[task(priority = 2, resources = [r])]
fn foo(cx: foo::Context) {
    cx.resources.r.lock(|r| r = /* ... */);
}

#[task(resources = [r])]
fn bar(cx: bar::Context) {
    cx.resources.r.lock(|r| r = /* ... */);
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that the performance does not change thanks to LLVM's optimizations which optimizes away unnecessary locks.</p>
<hr />
<h2 id="additions"><a class="header" href="#additions">Additions</a></h2>
<h3 id="extern-tasks"><a class="header" href="#extern-tasks">Extern tasks</a></h3>
<p>Both software and hardware tasks can now be defined external to the <code>mod app</code>. Previously this was possible only by implementing a trampoline calling out the task implementation.</p>
<p>See examples <code>examples/extern_binds.rs</code> and <code>examples/extern_spawn.rs</code>.</p>
<h1 id="migrating-from-v04x-to-v050"><a class="header" href="#migrating-from-v04x-to-v050">Migrating from v0.4.x to v0.5.0</a></h1>
<p>This section covers how to upgrade an application written against RTIC v0.4.x to
the version v0.5.0 of the framework.</p>
<h2 id="cargotoml"><a class="header" href="#cargotoml"><code>Cargo.toml</code></a></h2>
<p>First, the version of the <code>cortex-m-rtic</code> dependency needs to be updated to
<code>&quot;0.5.0&quot;</code>. The <code>timer-queue</code> feature needs to be removed.</p>
<pre><code class="language-toml">[dependencies.cortex-m-rtic]
# change this
version = &quot;0.4.3&quot;

# into this
version = &quot;0.5.0&quot;

# and remove this Cargo feature
features = [&quot;timer-queue&quot;]
#           ^^^^^^^^^^^^^
</code></pre>
<h2 id="context-argument"><a class="header" href="#context-argument"><code>Context</code> argument</a></h2>
<p>All functions inside the <code>#[rtic::app]</code> item need to take as first argument a
<code>Context</code> structure. This <code>Context</code> type will contain the variables that were
magically injected into the scope of the function by version v0.4.x of the
framework: <code>resources</code>, <code>spawn</code>, <code>schedule</code> -- these variables will become
fields of the <code>Context</code> structure. Each function within the <code>#[rtic::app]</code> item
gets a different <code>Context</code> type.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[rtic::app(/* .. */)]
const APP: () = {
    // change this
    #[task(resources = [x], spawn = [a], schedule = [b])]
    fn foo() {
        resources.x.lock(|x| /* .. */);
        spawn.a(message);
        schedule.b(baseline);
    }

    // into this
    #[task(resources = [x], spawn = [a], schedule = [b])]
    fn foo(mut cx: foo::Context) {
        // ^^^^^^^^^^^^^^^^^^^^

        cx.resources.x.lock(|x| /* .. */);
    //  ^^^

        cx.spawn.a(message);
    //  ^^^

        cx.schedule.b(message, baseline);
    //  ^^^
    }

    // change this
    #[init]
    fn init() {
        // ..
    }

    // into this
    #[init]
    fn init(cx: init::Context) {
        //  ^^^^^^^^^^^^^^^^^
        // ..
    }

    // ..
};
<span class="boring">}
</span></code></pre></pre>
<h2 id="resources-1"><a class="header" href="#resources-1">Resources</a></h2>
<p>The syntax used to declare resources has been changed from <code>static mut</code>
variables to a <code>struct Resources</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[rtic::app(/* .. */)]
const APP: () = {
    // change this
    static mut X: u32 = 0;
    static mut Y: u32 = (); // late resource

    // into this
    struct Resources {
        #[init(0)] // &lt;- initial value
        X: u32, // NOTE: we suggest changing the naming style to `snake_case`

        Y: u32, // late resource
    }

    // ..
};
<span class="boring">}
</span></code></pre></pre>
<h2 id="device-peripherals"><a class="header" href="#device-peripherals">Device peripherals</a></h2>
<p>If your application was accessing the device peripherals in <code>#[init]</code> through
the <code>device</code> variable then you'll need to add <code>peripherals = true</code> to the
<code>#[rtic::app]</code> attribute to continue to access the device peripherals through
the <code>device</code> field of the <code>init::Context</code> structure.</p>
<p>Change this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[rtic::app(/* .. */)]
const APP: () = {
    #[init]
    fn init() {
        device.SOME_PERIPHERAL.write(something);
    }

    // ..
};
<span class="boring">}
</span></code></pre></pre>
<p>Into this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[rtic::app(/* .. */, peripherals = true)]
//                    ^^^^^^^^^^^^^^^^^^
const APP: () = {
    #[init]
    fn init(cx: init::Context) {
        //  ^^^^^^^^^^^^^^^^^
        cx.device.SOME_PERIPHERAL.write(something);
    //  ^^^
    }

    // ..
};
<span class="boring">}
</span></code></pre></pre>
<h2 id="interrupt-and-exception"><a class="header" href="#interrupt-and-exception"><code>#[interrupt]</code> and <code>#[exception]</code></a></h2>
<p>The <code>#[interrupt]</code> and <code>#[exception]</code> attributes have been removed. To declare
hardware tasks in v0.5.x use the <code>#[task]</code> attribute with the <code>binds</code> argument.</p>
<p>Change this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[rtic::app(/* .. */)]
const APP: () = {
    // hardware tasks
    #[exception]
    fn SVCall() { /* .. */ }

    #[interrupt]
    fn UART0() { /* .. */ }

    // software task
    #[task]
    fn foo() { /* .. */ }

    // ..
};
<span class="boring">}
</span></code></pre></pre>
<p>Into this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[rtic::app(/* .. */)]
const APP: () = {
    #[task(binds = SVCall)]
    //     ^^^^^^^^^^^^^^
    fn svcall(cx: svcall::Context) { /* .. */ }
    // ^^^^^^ we suggest you use a `snake_case` name here

    #[task(binds = UART0)]
    //     ^^^^^^^^^^^^^
    fn uart0(cx: uart0::Context) { /* .. */ }

    #[task]
    fn foo(cx: foo::Context) { /* .. */ }

    // ..
};
<span class="boring">}
</span></code></pre></pre>
<h2 id="schedule"><a class="header" href="#schedule"><code>schedule</code></a></h2>
<p>The <code>schedule</code> API no longer requires the <code>timer-queue</code> cargo feature, which has
been removed. To use the <code>schedule</code> API one must
first define the monotonic timer the runtime will use using the <code>monotonic</code>
argument of the <code>#[rtic::app]</code> attribute. To continue using the cycle counter
(CYCCNT) as the monotonic timer, and match the behavior of version v0.4.x, add
the <code>monotonic = rtic::cyccnt::CYCCNT</code> argument to the <code>#[rtic::app]</code> attribute.</p>
<p>Also, the <code>Duration</code> and <code>Instant</code> types and the <code>U32Ext</code> trait have been moved
into the <code>rtic::cyccnt</code> module. This module is only available on ARMv7-M+
devices. The removal of the <code>timer-queue</code> also brings back the <code>DWT</code> peripheral
inside the core peripherals struct, this will need to be enabled by the application
inside <code>init</code>.</p>
<p>Change this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rtic::{Duration, Instant, U32Ext};

#[rtic::app(/* .. */)]
const APP: () = {
    #[task(schedule = [b])]
    fn a() {
        // ..
    }
};
<span class="boring">}
</span></code></pre></pre>
<p>Into this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rtic::cyccnt::{Duration, Instant, U32Ext};
//        ^^^^^^^^

#[rtic::app(/* .. */, monotonic = rtic::cyccnt::CYCCNT)]
//                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
const APP: () = {
    #[init]
    fn init(cx: init::Context) {
        cx.core.DWT.enable_cycle_counter();
        // optional, configure the DWT run without a debugger connected
        cx.core.DCB.enable_trace();
    }
    #[task(schedule = [b])]
    fn a(cx: a::Context) {
        // ..
    }
};
<span class="boring">}
</span></code></pre></pre>
<h1 id="migrating-from-rtfm-to-rtic"><a class="header" href="#migrating-from-rtfm-to-rtic">Migrating from RTFM to RTIC</a></h1>
<p>This section covers how to upgrade an application written against RTFM v0.5.x to
the same version of RTIC. This applies since the renaming of the framework as per <a href="https://github.com/rtic-rs/rfcs/pull/33">RFC #33</a>.</p>
<p><strong>Note:</strong> There are no code differences between RTFM v0.5.3 and RTIC v0.5.3, it is purely a name
change.</p>
<h2 id="cargotoml-1"><a class="header" href="#cargotoml-1"><code>Cargo.toml</code></a></h2>
<p>First, the <code>cortex-m-rtfm</code> dependency needs to be updated to
<code>cortex-m-rtic</code>.</p>
<pre><code class="language-toml">[dependencies]
# change this
cortex-m-rtfm = &quot;0.5.3&quot;

# into this
cortex-m-rtic = &quot;0.5.3&quot;
</code></pre>
<h2 id="code-changes"><a class="header" href="#code-changes">Code changes</a></h2>
<p>The only code change that needs to be made is that any reference to <code>rtfm</code> before now need to point
to <code>rtic</code> as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//
// Change this
//

#[rtfm::app(/* .. */, monotonic = rtfm::cyccnt::CYCCNT)]
const APP: () = {
    // ...

};

//
// Into this
//

#[rtic::app(/* .. */, monotonic = rtic::cyccnt::CYCCNT)]
const APP: () = {
    // ...

};
<span class="boring">}
</span></code></pre></pre>
<h1 id="under-the-hood"><a class="header" href="#under-the-hood">Under the hood</a></h1>
<p><strong>This is chapter is currently work in progress,
it will re-appear once it is more complete</strong></p>
<p>This section describes the internals of the RTIC framework at a <em>high level</em>.
Low level details like the parsing and code generation done by the procedural
macro (<code>#[app]</code>) will not be explained here. The focus will be the analysis of
the user specification and the data structures used by the runtime.</p>
<p>We highly suggest that you read the embedonomicon section on <a href="https://github.com/rust-embedded/embedonomicon/pull/48">concurrency</a>
before you dive into this material.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
